{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport TodoModel from './Mongo/models/Todo';\nimport mongoose from 'mongoose';\nconst connection = {\n  isConnected: false\n};\n\nconst connectDb = async () => {\n  if (connection.isConnected) {\n    return;\n  }\n\n  try {\n    const dbConnection = await mongoose.connect(process.env.MONGO_URL, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    });\n    connection.isConnected = !!dbConnection.connections[0].readyState;\n  } catch (err) {\n    console.error(`error connecting to db ${err.message || err}`);\n  }\n};\n\nfunction transformId(record) {\n  return {\n    id: record._id.toString(),\n    fields: record.fields\n  };\n}\n\nfunction transformIds(records) {\n  return records.map(transformId);\n}\n\nclass MongoDatabase {\n  async getAll({\n    filter = false\n  } = {}) {\n    let data = [];\n\n    if (filter) {\n      data = await TodoModel.find({\n        [`fields.${filter.field}`]: filter.value\n      }).sort('-createdAt').lean();\n    } else {\n      data = await TodoModel.find().sort('created_at').lean();\n    }\n\n    return transformIds(data);\n  }\n\n  async updateOne({\n    id,\n    fields\n  }) {\n    const updatedRecord = await TodoModel.findById(id);\n    updatedRecord.fields = _objectSpread(_objectSpread({}, updatedRecord.fields), fields);\n    await updatedRecord.save();\n    return updatedRecord;\n  }\n\n  async deleteOne({\n    id\n  }) {}\n\n  async createOne({\n    fields\n  }) {\n    const record = new TodoModel({\n      fields: _objectSpread({}, fields)\n    });\n    await record.save();\n    return transformId(record);\n  }\n\n  async findById({\n    id\n  }) {\n    const record = await TodoModel.findById(id).lean();\n\n    if (!record) {\n      throw new Error('Not found');\n    }\n\n    return transformId(record);\n  }\n\n}\n\nclass MongoDatabaseProxy {\n  constructor(connectDb) {\n    this.mongoDatabase = new MongoDatabase();\n    this.connectDb = connectDb;\n  }\n\n  async getAll(...props) {\n    await this.connectDb();\n    return await this.mongoDatabase.getAll(...props);\n  }\n\n  async updateOne(...props) {\n    await this.connectDb();\n    return await this.mongoDatabase.updateOne(...props);\n  }\n\n  async deleteOne(...props) {\n    await this.connectDb();\n    return await this.mongoDatabase.deleteOne(...props);\n  }\n\n  async createOne(...props) {\n    await this.connectDb();\n    return await this.mongoDatabase.createOne(...props);\n  }\n\n  async findById(...props) {\n    await this.connectDb();\n    return await this.mongoDatabase.findById(...props);\n  }\n\n}\n\nconst mongoDatabase = new MongoDatabaseProxy(connectDb);\nexport { mongoDatabase };","map":{"version":3,"sources":["/Users/misha/Documents/learn_project/JS/next-authenticated-todo-app/pages/api/utils/Mongo.js"],"names":["TodoModel","mongoose","connection","isConnected","connectDb","dbConnection","connect","process","env","MONGO_URL","useNewUrlParser","useUnifiedTopology","connections","readyState","err","console","error","message","transformId","record","id","_id","toString","fields","transformIds","records","map","MongoDatabase","getAll","filter","data","find","field","value","sort","lean","updateOne","updatedRecord","findById","save","deleteOne","createOne","Error","MongoDatabaseProxy","constructor","mongoDatabase","props"],"mappings":"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","sourcesContent":["import TodoModel from './Mongo/models/Todo'\nimport mongoose from 'mongoose'\n\nconst connection = {\n  isConnected: false,\n}\n\nconst connectDb = async () => {\n  if (connection.isConnected) {\n    return\n  }\n  try {\n    const dbConnection = await mongoose.connect(process.env.MONGO_URL, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    })\n    connection.isConnected = !!dbConnection.connections[0].readyState\n  } catch (err) {\n    console.error(`error connecting to db ${err.message || err}`)\n  }\n}\n\nfunction transformId(record) {\n  return {\n    id: record._id.toString(),\n    fields: record.fields,\n  }\n}\nfunction transformIds(records) {\n  return records.map(transformId)\n}\n\nclass MongoDatabase {\n  async getAll({ filter = false } = {}) {\n    let data = []\n    if (filter) {\n      data = await TodoModel.find({\n        [`fields.${filter.field}`]: filter.value,\n      })\n        .sort('-createdAt')\n        .lean()\n    } else {\n      data = await TodoModel.find().sort('created_at').lean()\n    }\n\n    return transformIds(data)\n  }\n  async updateOne({ id, fields }) {\n    const updatedRecord = await TodoModel.findById(id)\n    updatedRecord.fields = { ...updatedRecord.fields, ...fields }\n    await updatedRecord.save()\n    return updatedRecord\n  }\n  async deleteOne({ id }) {\n    \n  }\n  async createOne({ fields }) {\n    const record = new TodoModel({\n      fields: { ...fields },\n    })\n    await record.save()\n    return transformId(record)\n  }\n  async findById({ id }) {\n    const record = await TodoModel.findById(id).lean()\n    if (!record) {\n      throw new Error('Not found')\n    }\n    return transformId(record)\n  }\n}\n\nclass MongoDatabaseProxy {\n  constructor(connectDb) {\n    this.mongoDatabase = new MongoDatabase()\n    this.connectDb = connectDb\n  }\n  async getAll(...props) {\n    await this.connectDb()\n    return await this.mongoDatabase.getAll(...props)\n  }\n  async updateOne(...props) {\n    await this.connectDb()\n    return await this.mongoDatabase.updateOne(...props)\n  }\n  async deleteOne(...props) {\n    await this.connectDb()\n    return await this.mongoDatabase.deleteOne(...props)\n  }\n  async createOne(...props) {\n    await this.connectDb()\n    return await this.mongoDatabase.createOne(...props)\n  }\n  async findById(...props) {\n    await this.connectDb()\n    return await this.mongoDatabase.findById(...props)\n  }\n}\n\nconst mongoDatabase = new MongoDatabaseProxy(connectDb)\n\nexport { mongoDatabase }\n"]},"metadata":{},"sourceType":"module"}